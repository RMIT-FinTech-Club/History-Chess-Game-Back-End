generator client {
     output   = "../generated/client"
     provider = "prisma-client-js"
 }
 
 datasource db {
     provider = "mongodb"
     url      = env("MONGODB_URL")
 }
 
 model Games {
     id               String        @id @default(auto()) @map("_id") @db.ObjectId
     gameType         GameType
     players          Players
     current_state_id String?       @db.ObjectId
     mode             GameMode
     status           GameStatus
     aiDifficulty     AIDifficulty?
     nftskins         NFTSkins?
     timers           Timers?
     createdAt        DateTime      @default(now())
     updatedAt        DateTime      @updatedAt
 
     states      States[]      @relation("GameStates")
     moves       Moves[]       @relation("GameMoves")
     invitations Invitation[]  @relation("GameInvitations")
     history     GameHistory[] @relation("GameHistory")
 }
 
 type Players {
     white Int
     black Int
 }
 
 type NFTSkins {
     white Int?
     black Int?
 }
 
 type Timers {
     white TimerDetails
     black TimerDetails
 }
 
 type TimerDetails {
     startTime   DateTime
     currentTime Float
 }
 
 enum GameType {
     PLAYER_VS_PLAYER
     PLAYER_VS_AI
 }
 
 enum GameMode {
     PUBLIC
     PRIVATE
 }
 
 enum GameStatus {
     WAITING
     PAUSING
     ONGOING
     FINISHED
     RESIGNED
     TIMEOUT
 }
 
 enum AIDifficulty {
     EASY
     MEDIUM
     HARD
 }
 
 model MarketplaceListings {
     id              String        @id @default(auto()) @map("_id") @db.ObjectId
     nftId           String
     sellerId        String
     price           Float
     status          ListingStatus
     startTime       DateTime      @default(now())
     terminateTime   DateTime?
     transactionHash String?
 }
 
 enum ListingStatus {
     OPEN
     SOLD
     CANCELLED
     EXPIRED
 }

 enum NFTMarketplaceListingStatus {
  CREATE_PENDING
  CREATE_IN_NETWORK
  ON_SALE
  CREATE_ERROR
  PURCHASE_PENDING
  PURCHASE_IN_NETWORK
  PURCHASED
  PURCHASE_ERROR
  CANCEL_PENDING
  CANCEL_IN_NETWORK
  CANCELLED
  CANCEL_ERROR
}

model NFTMarketplaceListing {
  id                        String        @id @default(auto()) @map("_id") @db.ObjectId
  nftListingId              String        @unique // On-chain listing ID
  nftContractAddress        String
  tokenId                   String
  price                     String        
  status                    NFTMarketplaceListingStatus
  sellerAddress             String
  buyerAddress              String?       
  
  createTimestamp           DateTime?
  purchaseTimestamp         DateTime?
  cancelTimestamp           DateTime?
  
  createTxHash              String?       
  purchaseTxHash            String?     
  cancelTxHash              String?     
  
  createBlockNumber         String?
  purchaseBlockNumber       String?
  cancelBlockNumber         String?
}
 
 model GameHistory {
     id            String     @id @default(auto()) @map("_id") @db.ObjectId
     gameId        String     @db.ObjectId
     whitePlayerId String
     blackPlayerId String
     result        GameResult
     nftSkins      NFTSkins?
     completedTime DateTime
     game          Games      @relation("GameHistory", fields: [gameId], references: [id])
 }
 
 enum GameResult {
     WHITE_WINS
     BLACK_WINS
     WHITE_RESIGNS
     BLACK_RESIGNS
     WHITE_TIMEOUT
     BLACK_TIMEOUT
 }
 
 model Invitation {
     id          String           @id @default(auto()) @map("_id") @db.ObjectId
     gameId      String           @db.ObjectId
     token       String
     senderId    String
     recipientId String?
     status      InvitationStatus
     expiredAt   DateTime?
     createdAt   DateTime         @default(now())
     game        Games            @relation("GameInvitations", fields: [gameId], references: [id])
 }
 
 enum InvitationStatus {
     PENDING
     ACCEPTED
     EXPIRED
     CANCELLED
 }
 
 model Moves {
     id         String      @id @default(auto()) @map("_id") @db.ObjectId
     moveName   String
     playerId   String
     chessPiece String
     gameId     String      @db.ObjectId
     createdAt  DateTime    @default(now())
     isValid    Boolean
     result     MoveResult?
     game       Games       @relation("GameMoves", fields: [gameId], references: [id])
     states     States[]    @relation("MoveStates")
 }
 
 enum MoveResult {
     CHECK
     CHECKMATE
     STALEMATE
     NONE
 }
 
 model States {
     id         String   @id @default(auto()) @map("_id") @db.ObjectId
     gameId     String   @db.ObjectId
     moveId     String   @db.ObjectId
     boardState String
     updatedAt  DateTime @updatedAt
     turn       Turn
     game       Games    @relation("GameStates", fields: [gameId], references: [id])
     move       Moves    @relation("MoveStates", fields: [moveId], references: [id])
 }
 
 enum Turn {
     WHITE
     BLACK
 }